# Generated by Django 4.2.10 on 2024-05-16 12:10

from django.db import migrations, models


def strip_string_fields(apps, schema_editor):
    models_names = [
        "GeoCoordinateCache",
        "UserOrgAffiliationRequest",
        "UserOrgAffiliationRequestHistory",
        "VerificationQueueItem",
        "DeskProTicket",
        "DeskProTicketCC",
        "Organization",
        "OrganizationAPIKey",
        "OrganizationAPIPermission",
        "Sponsorship",
        "SponsorshipOrganization",
        "Partnership",
        "OrganizationMerge",
        "OrganizationMergeEntity",
        "Campus",
        "Facility",
        "InternetExchange",
        "InternetExchangeFacility",
        "IXLan",
        "IXLanIXFMemberImportAttempt",
        "IXLanIXFMemberImportLog",
        "IXLanIXFMemberImportLogEntry",
        "IXFMemberData",
        "IXLanPrefix",
        "Network",
        "NetworkContact",
        "NetworkFacility",
        "NetworkIXLan",
        "Carrier",
        "CarrierFacility",
        "User_groups",
        "User_user_permissions",
        "User",
        "UserAPIKey",
        "IXFImportEmail",
        "UserPasswordReset",
        "CommandLineTool",
        "EnvironmentSetting",
        "OAuthApplication",
        "OAuthGrantInfo",
        "OAuthAccessTokenInfo",
        "DataChangeWatchedObject",
        "DataChangeNotificationQueue",
        "EmailAddressData",
        "DataChangeEmail",
        "UserPermission",
    ]
    for model_name in models_names:
        model_class = apps.get_model("peeringdb_server", model_name)
        obj_to_update = []
        field_to_update = set()
        is_handleref = False
        try:
            try:
                model_data = model_class.objects.all()
            except AttributeError:
                model_data = model_class.handleref.all()
                is_handleref = True
            except Exception:
                continue

            print(
                f"Stripping leading and trailing white spaces off of text and char fields in {model_name}"
            )

            for instance in model_data:
                trailing_fields = []
                # Need to include the custom method because
                # the historical models will not have any custom methods
                # https://docs.djangoproject.com/en/4.0/topics/migrations/#historical-models
                for field in instance._meta.fields:
                    if isinstance(field, models.CharField | models.TextField):
                        value = getattr(instance, field.name)
                        if value and isinstance(value, str):
                            field_to_update.add(field.name)
                            if len(value) > len(value.strip()):
                                trailing_fields.append(field.name)
                                setattr(instance, field.name, value.strip())
                if not trailing_fields:
                    continue

                print(
                    f"[{model_name}] ID {instance.pk} has trailing spaces for fields {', '.join(trailing_fields)}"
                )
                obj_to_update.append(instance)

            if len(field_to_update):
                if is_handleref:
                    model_class.handleref.bulk_update(
                        obj_to_update, list(field_to_update)
                    )
                else:
                    model_class.objects.bulk_update(
                        obj_to_update, list(field_to_update)
                    )
        except Exception:
            pass


def reverse_code(apps, schema_editor):
    pass


class Migration(migrations.Migration):
    dependencies = [
        ("peeringdb_server", "0129_alter_property_help_text"),
    ]

    operations = [
        migrations.RunPython(strip_string_fields, reverse_code),
    ]
